## 一.（xginx）核心问题：为什么前端请求地址与后端不匹配，但请求能成功？

在项目中，我们经常会遇到这样的情况：

- **前端发出的 API 请求地址**：`http://localhost/api/employee/page`
- **后端服务器实际监听的地址**：`http://localhost:8080/admin/employee/page`

这两个地址明显不同（端口号和路径前缀都不同），但请求却能成功，数据也能正确返回。

**答案：** 因为 Nginx 在中间充当了“中间人”或“交通警察”的角色。这个过程被称为**反向代理**。



### 反向代理工作流程



1. **浏览器视角**：浏览器（前端页面）只知道一个服务器地址 `http://localhost` (默认是 80 端口)。无论是请求页面还是请求 API，它都只与 Nginx 对话。
2. **Nginx 的分发工作**：Nginx 监听 80 端口，接收所有请求。
   - 当请求是 `/` (访问主页) 时，Nginx 根据配置 (`root html/sky;`)，直接从自己的 `html/sky` 文件夹中返回静态页面。
   - 当请求是 `/api/...` 时，Nginx 根据配置 (`location /api/ { proxy_pass ... }`)，**在内部将这个请求转发给真正处理业务的后端服务器** (`http://localhost:8080/admin/...`)。
3. **后端服务器视角**：后端服务器（Tomcat）在 8080 端口接收到 Nginx 转发来的请求，处理完毕后，将响应数据返回给 Nginx。
4. **返回给浏览器**：Nginx 再将从后端拿到的响应数据，原封不动地返回给浏览器。

这个过程对浏览器是完全透明的，它始终认为自己是在和 `localhost:80` 这一个服务器通信。这样做最直接的好处就是**解决了浏览器跨域问题**，因为从浏览器的角度看，页面和 API 的访问地址是同源的（同协议、同域名、同端口）。



## 使用 Nginx 的三大核心优势



您的笔记总结得很好，下面我们对这三点进行详细补充。



### 1. 提高访问速度 (动静分离与缓存)



您提到的“提高访问速度”和“缓存”，在技术上通常被称为**“动静分离”**。

- **静态资源 (静)**：指不会变化的文件，如 HTML、CSS、JavaScript、图片等。Nginx 处理静态资源请求的能力极强，速度飞快，占用服务器资源极少。我们的前端项目 `dist` 包就是静态资源。
- **动态资源 (动)**：指需要后端经过业务逻辑处理和数据库查询才能返回的数据，如员工列表、菜品信息等。这类请求需要消耗更多的 CPU 和内存资源。

**Nginx 的作用：** Nginx 作为入口，将两类请求分离开。它自己直接处理所有静态资源请求，只有动态的 API 请求才会转发给后端相对“笨重”的应用服务器（如 Tomcat）。这大大减轻了后端服务器的压力，提升了网站整体的响应速度。

此外，Nginx 拥有强大的**缓存功能**，可以配置对不经常变化的静态资源或 API 数据进行缓存。当再次收到相同请求时，Nginx 可以直接从缓存中返回数据，而无需再次请求后端，极大地提高了访问速度。



### 2. 负载均衡 (Load Balancing)



这是 Nginx 在大型应用中扮演的关键角色。

当单一后端服务器无法承受所有访问压力时，我们可以启动多个相同的后端服务。Nginx 就可以在前面充当**请求分发器**。

```
# nginx.conf
http {
    # 定义一个后端服务器集群
    upstream webservers {
        server 192.168.1.101:8080;
        server 192.168.1.102:8080;
        server 192.168.1.103:8080;
    }

    server {
        location /api/ {
            # 将请求分发给服务器集群
            proxy_pass http://webservers/admin/;
        }
    }
}
```

**Nginx 的作用：** 将收到的 `/api/` 请求，通过预设的策略（轮询、权重、IP-Hash等）分发给后端的某一台服务器。

- **提高了系统的处理能力 (吞吐量)**：多台服务器一起工作。
- **提高了系统的可用性**：即使其中一台后端服务器宕机，Nginx 会自动将请求转发给其他健康的服务器，服务不会中断。



### 3. 保证后端服务安全 (安全隔离)



这是将后端服务部署在 Nginx 之后带来的一个巨大好处。

- **隐藏后端**：后端应用服务器（如 Tomcat）的 IP 地址和端口号（`8080`）完全不对外暴露。所有外部请求都只能访问 Nginx 的 `80` 端口。攻击者无法直接攻击脆弱的应用服务器。
- **充当安全屏障**：Nginx 本身是一个非常安全和稳定的软件，可以作为第一道防线。我们可以在 Nginx 层配置各种安全策略：
  - **防火墙**：配置只允许特定 IP 地址访问。
  - **HTTPS 加密**：配置 SSL 证书，实现 HTTPS 加密访问，而后端应用可以继续使用简单的 HTTP，降低了开发复杂度。
  - **访问控制**：对恶意请求、爬虫等进行拦截。
  - **限流**：防止恶意的高频次请求（DDoS 攻击）。

通过 Nginx 作为代理，我们的后端服务可以更安全地“躲”在内网中，专注于处理核心的业务逻辑。







# 二.YApi 与 Swagger/Knife4j 的协同工作



在项目开发中，我们需要一套高效的流程来设计、开发、测试和维护 API 接口。YApi 和 Swagger/Knife4j 就是这个流程中，分别负责不同阶段的优秀工具。



### 1. 各工具角色定位



| 工具        | 核心角色                     | 使用阶段               | 工作模式                                                     |
| ----------- | ---------------------------- | ---------------------- | ------------------------------------------------------------ |
| **YApi**    | API **设计与管理**平台       | **设计阶段**、维护阶段 | **手动**创建和维护接口信息，作为统一的 API 规范中心。        |
| **Swagger** | API **文档生成**框架         | **开发阶段**、测试阶段 | 通过在代码中添加**注解**，**自动**生成与代码同步的 API 文档。 |
| **Knife4j** | Swagger 的**增强与美化**工具 | 开发阶段、测试阶段     | **封装**了 Swagger，提供了一个功能更强、界面更美观的文档 UI。 |

### 2. 标准开发工作流



一个理想的开发流程是这样的：

1. **设计阶段 (使用 YApi)**：项目初期，前后端开发人员共同在 YApi 平台上定义好所有 API 接口的规范，包括路径、请求方法、参数、返回值等。此时 YApi 是唯一的“API 权威来源”。
2. **开发阶段 (使用 Swagger/Knife4j)**：后端开发者根据 YApi 上定义好的规范，在 Spring Boot 项目中编写 Controller 代码，并添加 Swagger 注解。
3. **自测与联调 (使用 Knife4j)**：后端开发者启动服务后，可以直接访问 Knife4j 生成的文档页面。这个页面是根据代码实时生成的，可以：
   - 检查自己写的接口是否和 YApi 上的设计稿一致。
   - 直接在页面上进行接口自测，确保功能正常。
   - 将此页面地址提供给前端开发者，作为最新的、可交互的联调文档。



### 3. Swagger 核心注解详解



Swagger 通过在代码中添加注解，来“感知”并收集 API 信息。这是实现“代码与文档同步”的关键。

- **`@Api`**: 用在 Controller 类上。
  - **作用**: 对整个 Controller 的功能进行分组和说明。
  - **示例**: `@Api(tags = "员工相关接口")`，在 Knife4j 页面上会生成一个名为“员工相关接口”的分类。
- **`@ApiOperation`**: 用在 Controller 的具体方法上。
  - **作用**: 说明该方法（即某个具体的 API 接口）的用途。
  - **示例**: `@ApiOperation("新增员工")`
- **`@ApiModel`**: 用在实体类上 (如 DTO, VO, Entity)。
  - **作用**: 对该 Java 类进行说明，将其定义为一个“模型”。
  - **示例**: `@ApiModel(description = "员工登录时传递的数据模型")`
- **`@ApiModelProperty`**: 用在实体类的**字段**上。
  - **作用**: 对模型中的每一个属性进行详细描述。
  - **示例**: `@ApiModelProperty("用户名") private String username;`

当项目启动后，Knife4j 会扫描所有这些注解，并将收集到的信息整合渲染成一个美观的 Web 页面，供开发者查阅和测试。





# 三.MyBatis-Plus (MP) 核心用法



### 1. 通用 CRUD：继承 `BaseMapper`



这是 MP 最核心的功能。您只需要创建一个 Mapper 接口，并让它继承 MP 提供的 `BaseMapper<T>` 接口，就可以“凭空”获得一套强大的、开箱即用的增删改查方法。

```java
// 1. 定义与数据库表对应的实体类
@TableName("employee")
public class Employee {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String username;
    // ...
}

// 2. 创建 Mapper 接口，继承 BaseMapper
@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
    // 无需编写任何方法！
}

// 3. 在 Service 中直接使用
@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    public void test() {
        // 直接调用，无需编写 SQL
        Employee e = employeeMapper.selectById(1L); 
        employeeMapper.deleteById(1L);
    }
}
```



### 2. 动态条件查询：使用 `QueryWrapper`



对于稍微复杂的条件查询，`BaseMapper` 无法直接满足。此时，您可以使用**条件构造器 (`QueryWrapper` 或 `LambdaQueryWrapper`)** 来灵活地构建查询条件，而无需编写 XML。

`LambdaQueryWrapper` 是更被推荐的方式，因为它可以利用 Java 8 的方法引用，防止手写字段名出错。



```java
@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    public List<Employee> findEmployee(String name, Integer status) {
        // 创建 Lambda 条件构造器
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        
        // 构建查询条件：
        // 1. WHERE name LIKE '%关键字%'
        queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);
        
        // 2. AND status = ?
        queryWrapper.eq(status != null, Employee::getStatus, status);
        
        // 调用 selectList 方法，传入构造好的条件
        return employeeMapper.selectList(queryWrapper);
    }
}
```



















# 乌龙事件

![image-20250920140651037](D:\porjects\Food_Delivery\Food_Delivery\md\图片\知识点.md)

其实加了注解自增id实现了已经，但是我看这么长的id还以为是雪花算法，用尽各种方法，白忙活一场





