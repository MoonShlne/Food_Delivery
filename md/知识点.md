## 一.（xginx）核心问题：为什么前端请求地址与后端不匹配，但请求能成功？

在项目中，我们经常会遇到这样的情况：

- **前端发出的 API 请求地址**：`http://localhost/api/employee/page`
- **后端服务器实际监听的地址**：`http://localhost:8080/admin/employee/page`

这两个地址明显不同（端口号和路径前缀都不同），但请求却能成功，数据也能正确返回。

**答案：** 因为 Nginx 在中间充当了“中间人”或“交通警察”的角色。这个过程被称为**反向代理**。



### 反向代理工作流程



1. **浏览器视角**：浏览器（前端页面）只知道一个服务器地址 `http://localhost` (默认是 80 端口)。无论是请求页面还是请求 API，它都只与 Nginx 对话。
2. **Nginx 的分发工作**：Nginx 监听 80 端口，接收所有请求。
   - 当请求是 `/` (访问主页) 时，Nginx 根据配置 (`root html/sky;`)，直接从自己的 `html/sky` 文件夹中返回静态页面。
   - 当请求是 `/api/...` 时，Nginx 根据配置 (`location /api/ { proxy_pass ... }`)，**在内部将这个请求转发给真正处理业务的后端服务器** (`http://localhost:8080/admin/...`)。
3. **后端服务器视角**：后端服务器（Tomcat）在 8080 端口接收到 Nginx 转发来的请求，处理完毕后，将响应数据返回给 Nginx。
4. **返回给浏览器**：Nginx 再将从后端拿到的响应数据，原封不动地返回给浏览器。

这个过程对浏览器是完全透明的，它始终认为自己是在和 `localhost:80` 这一个服务器通信。这样做最直接的好处就是**解决了浏览器跨域问题**，因为从浏览器的角度看，页面和 API 的访问地址是同源的（同协议、同域名、同端口）。



## 使用 Nginx 的三大核心优势



您的笔记总结得很好，下面我们对这三点进行详细补充。



### 1. 提高访问速度 (动静分离与缓存)



您提到的“提高访问速度”和“缓存”，在技术上通常被称为**“动静分离”**。

- **静态资源 (静)**：指不会变化的文件，如 HTML、CSS、JavaScript、图片等。Nginx 处理静态资源请求的能力极强，速度飞快，占用服务器资源极少。我们的前端项目 `dist` 包就是静态资源。
- **动态资源 (动)**：指需要后端经过业务逻辑处理和数据库查询才能返回的数据，如员工列表、菜品信息等。这类请求需要消耗更多的 CPU 和内存资源。

**Nginx 的作用：** Nginx 作为入口，将两类请求分离开。它自己直接处理所有静态资源请求，只有动态的 API 请求才会转发给后端相对“笨重”的应用服务器（如 Tomcat）。这大大减轻了后端服务器的压力，提升了网站整体的响应速度。

此外，Nginx 拥有强大的**缓存功能**，可以配置对不经常变化的静态资源或 API 数据进行缓存。当再次收到相同请求时，Nginx 可以直接从缓存中返回数据，而无需再次请求后端，极大地提高了访问速度。



### 2. 负载均衡 (Load Balancing)



这是 Nginx 在大型应用中扮演的关键角色。

当单一后端服务器无法承受所有访问压力时，我们可以启动多个相同的后端服务。Nginx 就可以在前面充当**请求分发器**。

```
# nginx.conf
http {
    # 定义一个后端服务器集群
    upstream webservers {
        server 192.168.1.101:8080;
        server 192.168.1.102:8080;
        server 192.168.1.103:8080;
    }

    server {
        location /api/ {
            # 将请求分发给服务器集群
            proxy_pass http://webservers/admin/;
        }
    }
}
```

**Nginx 的作用：** 将收到的 `/api/` 请求，通过预设的策略（轮询、权重、IP-Hash等）分发给后端的某一台服务器。

- **提高了系统的处理能力 (吞吐量)**：多台服务器一起工作。
- **提高了系统的可用性**：即使其中一台后端服务器宕机，Nginx 会自动将请求转发给其他健康的服务器，服务不会中断。



### 3. 保证后端服务安全 (安全隔离)



这是将后端服务部署在 Nginx 之后带来的一个巨大好处。

- **隐藏后端**：后端应用服务器（如 Tomcat）的 IP 地址和端口号（`8080`）完全不对外暴露。所有外部请求都只能访问 Nginx 的 `80` 端口。攻击者无法直接攻击脆弱的应用服务器。
- **充当安全屏障**：Nginx 本身是一个非常安全和稳定的软件，可以作为第一道防线。我们可以在 Nginx 层配置各种安全策略：
  - **防火墙**：配置只允许特定 IP 地址访问。
  - **HTTPS 加密**：配置 SSL 证书，实现 HTTPS 加密访问，而后端应用可以继续使用简单的 HTTP，降低了开发复杂度。
  - **访问控制**：对恶意请求、爬虫等进行拦截。
  - **限流**：防止恶意的高频次请求（DDoS 攻击）。

通过 Nginx 作为代理，我们的后端服务可以更安全地“躲”在内网中，专注于处理核心的业务逻辑。







# 二.YApi 与 Swagger/Knife4j 的协同工作



在项目开发中，我们需要一套高效的流程来设计、开发、测试和维护 API 接口。YApi 和 Swagger/Knife4j 就是这个流程中，分别负责不同阶段的优秀工具。



### 1. 各工具角色定位



| 工具        | 核心角色                     | 使用阶段               | 工作模式                                                     |
| ----------- | ---------------------------- | ---------------------- | ------------------------------------------------------------ |
| **YApi**    | API **设计与管理**平台       | **设计阶段**、维护阶段 | **手动**创建和维护接口信息，作为统一的 API 规范中心。        |
| **Swagger** | API **文档生成**框架         | **开发阶段**、测试阶段 | 通过在代码中添加**注解**，**自动**生成与代码同步的 API 文档。 |
| **Knife4j** | Swagger 的**增强与美化**工具 | 开发阶段、测试阶段     | **封装**了 Swagger，提供了一个功能更强、界面更美观的文档 UI。 |

### 2. 标准开发工作流



一个理想的开发流程是这样的：

1. **设计阶段 (使用 YApi)**：项目初期，前后端开发人员共同在 YApi 平台上定义好所有 API 接口的规范，包括路径、请求方法、参数、返回值等。此时 YApi 是唯一的“API 权威来源”。
2. **开发阶段 (使用 Swagger/Knife4j)**：后端开发者根据 YApi 上定义好的规范，在 Spring Boot 项目中编写 Controller 代码，并添加 Swagger 注解。
3. **自测与联调 (使用 Knife4j)**：后端开发者启动服务后，可以直接访问 Knife4j 生成的文档页面。这个页面是根据代码实时生成的，可以：
   - 检查自己写的接口是否和 YApi 上的设计稿一致。
   - 直接在页面上进行接口自测，确保功能正常。
   - 将此页面地址提供给前端开发者，作为最新的、可交互的联调文档。



### 3. Swagger 核心注解详解



Swagger 通过在代码中添加注解，来“感知”并收集 API 信息。这是实现“代码与文档同步”的关键。

- **`@Api`**: 用在 Controller 类上。
  - **作用**: 对整个 Controller 的功能进行分组和说明。
  - **示例**: `@Api(tags = "员工相关接口")`，在 Knife4j 页面上会生成一个名为“员工相关接口”的分类。
- **`@ApiOperation`**: 用在 Controller 的具体方法上。
  - **作用**: 说明该方法（即某个具体的 API 接口）的用途。
  - **示例**: `@ApiOperation("新增员工")`
- **`@ApiModel`**: 用在实体类上 (如 DTO, VO, Entity)。
  - **作用**: 对该 Java 类进行说明，将其定义为一个“模型”。
  - **示例**: `@ApiModel(description = "员工登录时传递的数据模型")`
- **`@ApiModelProperty`**: 用在实体类的**字段**上。
  - **作用**: 对模型中的每一个属性进行详细描述。
  - **示例**: `@ApiModelProperty("用户名") private String username;`

当项目启动后，Knife4j 会扫描所有这些注解，并将收集到的信息整合渲染成一个美观的 Web 页面，供开发者查阅和测试。





# 三.MyBatis-Plus (MP) 核心用法



### 1. 通用 CRUD：继承 `BaseMapper`



这是 MP 最核心的功能。您只需要创建一个 Mapper 接口，并让它继承 MP 提供的 `BaseMapper<T>` 接口，就可以“凭空”获得一套强大的、开箱即用的增删改查方法。

```java
// 1. 定义与数据库表对应的实体类
@TableName("employee")
public class Employee {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String username;
    // ...
}

// 2. 创建 Mapper 接口，继承 BaseMapper
@Mapper
public interface EmployeeMapper extends BaseMapper<Employee> {
    // 无需编写任何方法！
}

// 3. 在 Service 中直接使用
@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    public void test() {
        // 直接调用，无需编写 SQL
        Employee e = employeeMapper.selectById(1L); 
        employeeMapper.deleteById(1L);
    }
}
```



### 2. 动态条件查询：使用 `QueryWrapper`



对于稍微复杂的条件查询，`BaseMapper` 无法直接满足。此时，您可以使用**条件构造器 (`QueryWrapper` 或 `LambdaQueryWrapper`)** 来灵活地构建查询条件，而无需编写 XML。

`LambdaQueryWrapper` 是更被推荐的方式，因为它可以利用 Java 8 的方法引用，防止手写字段名出错。



```java
@Service
public class EmployeeService {
    @Autowired
    private EmployeeMapper employeeMapper;

    public List<Employee> findEmployee(String name, Integer status) {
        // 创建 Lambda 条件构造器
        LambdaQueryWrapper<Employee> queryWrapper = new LambdaQueryWrapper<>();
        
        // 构建查询条件：
        // 1. WHERE name LIKE '%关键字%'
        queryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);
        
        // 2. AND status = ?
        queryWrapper.eq(status != null, Employee::getStatus, status);
        
        // 调用 selectList 方法，传入构造好的条件
        return employeeMapper.selectList(queryWrapper);
    }
}
```







# 四.AOP面向切面编程

### AOP 实现的核心步骤





#### 1. 创建切面 (Aspect) 类



首先，我们需要一个普通的 Java 类来承载我们所有的“横切”逻辑。为了让 Spring 识别它是一个切面，我们需要添加两个注解：

- **`@Aspect`**：声明这个类是一个**切面**。
- **`@Component`**：将这个切面类本身也作为一个 Bean 交给 Spring IoC 容器管理，这样 Spring 才能发现并使用它。

Java

```java
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Aspect      // 1. 声明为切面
@Component   // 2. 声明为 Spring 的组件
public class MyLoggingAspect {
    // ... 切点和通知将定义在这里 ...
}
```



#### 2. 定义切点 (Pointcut)



切点的作用是**“定位”**，它通过一个表达式来精确地圈定：“**我们的增强逻辑到底要作用于哪些方法上？**”

- 使用 **`@Pointcut`** 注解来定义一个切点。
- 其值是一个**切点表达式**，最常用的 `execution()` 表达式可以匹配到具体的方法。

Java

```java
@Aspect
@Component
public class MyLoggingAspect {

    /**
     * 定义一个切点。
     * execution(* com.sky.service.*.*(..)) 的含义是：
     * - * : 匹配任意返回值类型
     * - com.sky.service.* : 匹配 com.sky.service 包下的所有类
     * - .* : 匹配类中的所有方法
     * - (..) : 匹配任意数量、任意类型的参数
     */
    @Pointcut("execution(* com.sky.service.*.*(..))")
    public void serviceLayerPointcut() {} // 这个方法体是空的，它只作为切点表达式的载体

}
```



#### 3. (可选但推荐) 使用自定义注解精确定位



- **`@Pointcut("... && @annotation(...)")`**：我们可以通过 `&& @annotation(...)` 的方式，要求目标方法**不仅要满足 `execution` 表达式，还必须被我们自定义的注解所标记**。

```java
// 假设我们有一个自定义注解 @MyLog
@Pointcut("execution(* com.sky.service.*.*(..)) && @annotation(com.sky.annotation.MyLog)")
public void loggedMethodPointcut() {}
```

这样，只有 Service 包下，且明确写了 `@MyLog` 注解的方法才会被拦截，避免了“误伤”其他不需要记录日志的方法。



#### 4. 编写通知 (Advice)

通知定义了**“做什么”**和**“在什么时候做”**。我们通过不同的通知注解，将我们的逻辑代码“织入”到切点所匹配的方法的不同执行时机。

- **`@Before` (前置通知)**：在目标方法执行**前**运行。
- **`@After` (后置通知)**：在目标方法执行**后**运行 (无论成功或失败)。
- **`@AfterReturning` (返回通知)**：在目标方法**成功返回**结果后运行。
- **`@AfterThrowing` (异常通知)**：在目标方法**抛出异常**后运行。
- **`@Around` (环绕通知)**：功能最强大的通知，可以完全控制目标方法的执行。

```java
@Aspect
@Component
@Slf4j
public class MyLoggingAspect {

    @Pointcut("execution(* com.sky.service.*.*(..))")
    public void serviceLayerPointcut() {}

    /**
     * 前置通知：在切点匹配的方法执行前，打印入参日志
     * "serviceLayerPointcut()" 表示引用上面定义的切点
     */
    @Before("serviceLayerPointcut()")
    public void logBefore(JoinPoint joinPoint) {
        // JoinPoint 对象可以用来获取目标方法的信息，如方法名、参数等
        String methodName = joinPoint.getSignature().getName();
        Object[] args = joinPoint.getArgs();
        log.info("方法 [{}] 开始执行，参数: {}", methodName, args);
    }
    
    /**
     * 返回通知：在方法成功返回后，打印返回值
     */
    @AfterReturning(pointcut = "serviceLayerPointcut()", returning = "result")
    public void logAfterReturning(JoinPoint joinPoint, Object result) {
        String methodName = joinPoint.getSignature().getName();
        log.info("方法 [{}] 执行成功，返回值: {}", methodName, result);
    }
}
```



# 五.Mybatis Plus 实现自动填充

https://baomidou.com/guides/auto-fill-field/



### 六、 使用云端 OSS (对象存储服务)

在现代 Web 应用中，处理用户上传的文件（如图片、视频、附件）是一个常见的需求。相比于传统的本地存储，使用云端对象存储服务 (OSS) 是一种更先进、更可靠的解决方案。

### 1. 核心思想：分离应用与文件

OSS 的核心思想是将**应用程序（后端服务）\**与它需要管理的\**静态文件**进行**物理分离**。应用程序不再负责文件的存储和传输，而是将这项专业的工作外包给可靠的云服务商。

- **使用云端可以更方便的储存**：我们将文件上传到由云服务商（如阿里云、腾讯云）提供的、容量几乎无限、高可用的专用存储集群中。
- **前端也可以直接访问云端数据回显**：后端在数据库中只存储文件的 **URL 地址**。前端在需要显示图片等文件时，直接通过这个公网 URL 向 OSS 服务器请求，**完全不占用**我们自己后端应用服务器的带宽和计算资源。

### 2.实现图片回显

**上传**：前端管理员在后台上传一张菜品图片。

**中转**：请求首先到达我们的后端 Spring Boot 服务。

**转存 OSS**：后端服务通过调用阿里云 OSS 的 SDK，将接收到的图片文件上传到我们预先创建好的 **Bucket (存储桶)** 中。

**获取 URL**：OSS 成功存储文件后，会返回一个独一无二的、可通过公网访问的 URL 地址。

**持久化**：后端服务将这个 **URL 地址**（而不是文件本身）保存到数据库的 `dish` 表中对应的 `image` 字段里。

**回显**：当用户端或管理端需要显示这张图片时，前端直接从 API 获取到这个 URL，然后将其用在 `<img>` 标签的 `src` 属性上，浏览器会直接向阿里云 OSS 服务器请求图片并显示。

### 3 环境隔离与安全实践

- **多环境存储桶 (Bucket)**：为了实现开发环境和生产环境的隔离，我们应该创建不同的 Bucket。
- 还能实现权限隔离

# :star: 细碎知识



## 1.消息转换器

原因，返回前端的时间类型会被解析为数组

解决方法

1.在实体类添加注解，@jsonformat

2.配置消息转换器统一处理  （没搞懂





## 2.网页的调试功能并不能看到拦截器处理的请求

拦截器（Interceptor）不是一个“请求”，而是对每个请求进行拦截和处理的组件。它的作用是在请求到达 Controller 之前（或之后）进行统一的预处理或后处理，比如校验 token、权限检查、日志记录等。







## 3.wrapper的泛型作用

1.找到要应用的数据库

2.确定返回值类型

3.启动lambda表达式 







# 乌龙事件

![image-20250920140651037](D:\porjects\Food_Delivery\Food_Delivery\md\图片\知识点.md)

其实加了注解自增id实现了已经，但是我看这么 长的id还以为是雪花算法，用尽各种方法，白忙活一场





# 创新点

使用mybatis plus 来实现 mapper查询

使用mybayis plus 的自带hook功能，实现公共字段的填充

使用CI/CD  实现持续实时的服务器部署

CI/CD 是一种现代化的软件开发实践，它将**代码集成 (Integration)**、**构建 (Build)**、**测试 (Test)** 和 **部署 (Deployment)** 这一系列繁琐的手动操作，转变为一个自动化的、可靠的流水线。
